from prophet import Prophet
import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from sklearn.metrics import mean_absolute_percentage_error

def prophet_volatility_train_test_tab(df, df_summary, roll_window=30):
    st.header("üìä Prophet-Based Volatility Thresholding (Train/Test)")

    selected_currency = st.selectbox("Select Currency", df["Currency"].unique(), key="tab6_vol_currency")
    test_days = st.slider("Test Window (days)", 10, 90, 30)

    df_cur = df[df["Currency"] == selected_currency].copy().sort_values("Date")
    df_cur["LogReturn"] = np.log(df_cur["Close"] / df_cur["Close"].shift(1))
    df_cur["Volatility"] = df_cur["LogReturn"].rolling(window=roll_window, min_periods=roll_window).std() * np.sqrt(252)
    df_vol = df_cur[["Date", "Volatility"]].dropna().copy()
    df_vol = df_vol.rename(columns={"Date": "ds", "Volatility": "y"})

    if df_vol.empty or len(df_vol) < test_days + 50:
        st.warning("Not enough data for train/test split. Try reducing the test window.")
        return

    # Split into train/test
    df_train = df_vol[:-test_days]
    df_test = df_vol[-test_days:]

    model = Prophet(interval_width=0.90, daily_seasonality=False)
    model.fit(df_train)

    future = df_test[["ds"]]  # future = known test window
    forecast = model.predict(future)

    # Evaluation
    y_true = df_test["y"].values
    y_pred = forecast["yhat"].values
    mape = mean_absolute_percentage_error(y_true, y_pred) * 100

    # Fetch manual threshold
    thresh = df_summary[df_summary["Currency"] == selected_currency.upper()]["ManualThreshold"]
    manual_thresh = thresh.values[0] if not thresh.empty else None

    # Flag where actual volatility breaches upper band
    flags = df_test["y"].values > forecast["yhat_upper"].values

    # Plot
    st.subheader(f"{selected_currency} Volatility Forecast vs Actual (Test Window)")
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=df_vol["ds"], y=df_vol["y"], name="Observed Volatility", line=dict(color="gray")))
    fig.add_trace(go.Scatter(x=forecast["ds"], y=forecast["yhat"], name="Forecast (Prophet)", line=dict(color="blue")))
    fig.add_trace(go.Scatter(x=forecast["ds"], y=forecast["yhat_upper"], name="Upper CI", line=dict(color="lightblue", dash="dot")))
    fig.add_trace(go.Scatter(x=forecast["ds"], y=forecast["yhat_lower"], name="Lower CI", line=dict(color="lightblue", dash="dot")))

    if manual_thresh is not None:
        fig.add_hline(y=manual_thresh, line_color="red", line_dash="dash", annotation_text="Manual Threshold")

    # Add flagged points
    flagged_dates = df_test["ds"].values[flags]
    flagged_vols = df_test["y"].values[flags]
    fig.add_trace(go.Scatter(x=flagged_dates, y=flagged_vols,
                             mode="markers", name="Flagged Breach",
                             marker=dict(color="red", size=8, symbol="x")))

    fig.update_layout(title=f"{selected_currency}: Volatility vs Prophet CI and Manual Threshold",
                      xaxis_title="Date", yaxis_title="Annualized Volatility", height=500)
    st.plotly_chart(fig, use_container_width=True)

    # Table of flagged rows
    flagged_df = df_test[flags].copy()
    flagged_df["UpperBand"] = forecast["yhat_upper"].values[flags]
    flagged_df["Deviation %"] = ((flagged_df["y"] - flagged_df["UpperBand"]) / flagged_df["UpperBand"]) * 100
    st.markdown(f"‚úÖ **Test MAPE**: `{mape:.2f}%`")

    if not flagged_df.empty:
        st.markdown("### üîç Flagged Breaches")
        st.dataframe(flagged_df[["ds", "y", "UpperBand", "Deviation %"]].rename(columns={
            "ds": "Date", "y": "Volatility"
        }), use_container_width=True)

    st.markdown("### üìò Interpretation")
    st.markdown("""
    - Prophet models **volatility trend**, not FX rate  
    - Red markers = volatility exceeded Prophet‚Äôs 90% band  
    - Manual threshold overlaid for business comparison  
    - Helps identify threshold breaches **statistically**, without relying on fixed rules  
    """)
